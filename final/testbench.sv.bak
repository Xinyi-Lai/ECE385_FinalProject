module testbench();

	timeunit 10ns;	// Half clock cycle at 50 MHz
						// This is the amount of time represented by #1 
	timeprecision 1ns;

	// These signals are internal because the processor will be 
	// instantiated as a submodule in testbench.
	logic Clk = 0;
	
	// Toggle the clock
	// #1 means wait for a delay of 1 timeunit
	always begin : CLOCK_GENERATION
		#1 Clk = ~Clk;
	end

	initial begin: CLOCK_INITIALIZATION
		 Clk = 0;
	end 


	// Testing begins here
	// The initial block is not synthesizable
	// Everything happens sequentially inside an initial block
	// as in a software program
	
	
//	// unit test: AddRoundKey
//	logic [127:0] data_in_myadd, key_myadd, data_out_myadd;
//	assign data_in_myadd = 128'h01010101010101010101010101010101;
//	assign key_myadd = 128'h00110011001100110011001100110011;
//	AddRoundKey myadd(.data_in(data_in_myadd), .key(key_myadd), .data_out(data_out_myadd));
//
//	// unit test: InvSubStates
//	logic [127:0] data_in_mysub, data_out_mysub;
//	assign data_in_mysub = 128'h000102030405060708090a0b0c0d0e0f;
//	InvSubStates mysub(.CLK(Clk), .data_in(data_in_mysub), .data_out(data_out_mysub));
//	
//	// unit test: KeyExpansion
//	logic [127:0] Cipherkey;
//	logic [1407:0] KeySchedule;
//	assign Cipherkey = 128'h000102030405060708090a0b0c0d0e0f;
//	KeyExpansion mykey(.clk(Clk), .*);
	
	
//	module AES (
//	input	 logic CLK,
//	input  logic RESET,
//	input  logic AES_START,
//	output logic AES_DONE,
//	input  logic [127:0] AES_KEY,
//	input  logic [127:0] AES_MSG_ENC,
//	output logic [127:0] AES_MSG_DEC
//);
	logic RESET, AES_START, AES_DONE;
	logic [127:0] AES_KEY, AES_MSG_ENC, AES_MSG_DEC;
	AES myaes(.CLK(Clk), .*);
	
	logic [127:0] curr_data;
	assign curr_data = myaes.curr_data;
	logic [3:0] round;
	assign round = myaes.round;
	logic [4:0] curr_state;
	assign curr_state = myaes.curr_state;
	
		
	initial begin: TEST_VECTORS
	RESET = 0;
	AES_START = 0;
	AES_DONE = 0;
	AES_KEY = 128'h000102030405060708090a0b0c0d0e0f;
	AES_MSG_ENC = 128'hdaec3055df058e1c39e814ea76f6747e;
	
	
	#2 AES_START = 1;
	
	end


endmodule
