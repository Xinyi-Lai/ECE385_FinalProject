//-------------------------------------------------------------------------
//    background.sv Spring 2020											 --
//    Adapted from Ball.sv, lab8                                         --
//    Store the position, motion and shape of the ground                 --
//    Tell the ColorMapper whether this pixel is a part of the stickman  --
//-------------------------------------------------------------------------


module  ground ( input  Clk,                // 50 MHz clock
                        Reset,              // Active-high reset signal
                        frame_clk,          // The clock indicating a new frame (~60Hz)
                input [9:0]   DrawX, DrawY,    // Current pixel coordinates
                output [9:0]  GroundY,          // The height of the floor at where the stickman stands 
                output logic  is_ground    // Whether current pixel belongs to ball or background
				);

    parameter [11:0] frame_counter_max =16'd4096;
    parameter [9:0] screen_Xmax = 10'd639;      // Rightmost point on the X axis of the screen
    parameter [9:0] stickman_X = 10'd100;       // x position of the stickman
	
	parameter [9:0] ground_height = 10'd360; 	// attitude of ground
    parameter [9:0] upstair_height = 10'd300;
    parameter [9:0] downstair_height = 10'd420;
    parameter [9:0] obstacle_height = 10'd340; 
    parameter [9:0] pitfall_height = 10'd479; 
	
    logic [11:0] frame_counter, frame_counter_in;
    logic [9:0] height[frame_counter_max+Screen_max];

    
    // Detect rising edge of frame_clk
    logic frame_clk_delayed, frame_clk_rising_edge;
    always_ff @ (posedge Clk) begin
        frame_clk_delayed <= frame_clk;
        frame_clk_rising_edge <= (frame_clk == 1'b1) && (frame_clk_delayed == 1'b0);
    end
    // Update registers
    always_ff @ (posedge Clk)
    begin
        if (Reset)
            frame_counter <= 16'd0;
        else
			frame_counter <=frame_counter_in;
    end

    // terrain
    always_comb
    begin
        for (int i=0; i<300; i++)
			height[i] = ground_height;
        for (int i=300; i<400; i++) 
            height[i] = pitfall_height;
        for (int i=400; i<800;i++) 
            height[i] = ground_height;
        for (int i=800; i<1000;i++) 
            height[i] = upstair_height;
        for (int i=1000; i<1500;i++) 
            height[i] = ground_height;
        for (int i=1500; i<2000;i++) 
            height[i] = downstair_height;
        for (int i=2000; i<frame_counter_max+Screen_max;i++) 
            height[i] = ground_height;
    end

    // frame counter
    always_comb
    begin
        // By default, unchanged
        frame_counter_in = frame_counter;
        // Update only at rising edge of frame clock
        if (frame_clk_rising_edge)
        begin
			if(frame_counter == frame_counter_max)
                frame_counter_in = 16'd0;
            else
                frame_counter_in = frame_counter + 1'd1;
        end
    end
    
    // Compute whether the pixel corresponds to the ground or background
    always_comb 
    begin
        if (DrawY >= height[frame_counter+DrawX]) //get the height threshold  
            is_ground = 1'b1;
        else
            is_ground = 1'b0;
    end

    assign GroundY = height[frame_counter + stickman_X];
    
endmodule